# -*- coding: utf-8 -*-
"""
Created on Thu Dec 17 21:43:51 2020

@author: wpc
"""

from lxml import etree
# import argparse
# import random
import numpy as np
import math
import uuid
# import copy
# import re as regular
import os
# import ctypes
import coor_opening4
import joblib

DIRECTORY=r'lod3'
if os.path.exists(DIRECTORY) is not True:
    os.mkdir(DIRECTORY)
# DIRECTORY=r'C:\Users\wpc\Desktop\lod223\lod3'


ns_citygml = "http://www.opengis.net/citygml/2.0"

ns_gml = "http://www.opengis.net/gml"
ns_bldg = "http://www.opengis.net/citygml/building/2.0"
ns_tran = "http://www.opengis.net/citygml/transportation/2.0"
ns_veg = "http://www.opengis.net/citygml/vegetation/2.0"
ns_xsi = "http://www.w3.org/2001/XMLSchema-instance"
ns_xAL = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
ns_xlink = "http://www.w3.org/1999/xlink"
ns_dem = "http://www.opengis.net/citygml/relief/2.0"
ns_fme = "http://www.safe.com/xml/xmltables"

ns_app = "http://www.opengis.net/citygml/appearance/2.0"
ns_gen = "http://www.opengis.net/citygml/generics/2.0"

nsmap = {
    None: ns_citygml,
    'gml': ns_gml,
    'bldg': ns_bldg,
    'tran': ns_tran,
    'veg': ns_veg,
    'xsi': ns_xsi,
    'xAL': ns_xAL,
    'xlink': ns_xlink,
    'dem': ns_dem,
    'fme': ns_fme,
    'app' : ns_app,
    'gen' : ns_gen
}

def createCityGML(suffix):
    """Creates a CityGML foundation to be filled later by the remaining part of the script."""
    CityModel = etree.Element("CityModel", nsmap=nsmap)
    citymodelname = etree.SubElement(CityModel, "{%s}name" % ns_gml)
    citymodelname.text = str(suffix)
    # boundedBy = etree.SubElement(CityModel, "{%s}boundedBy" % ns_gml)
    # Envelope = etree.SubElement(boundedBy, "{%s}Envelope" % ns_gml, srsDimension="3")
    # Envelope.attrib["srsName"] = "EPSG:28992"
    # lowercorner = etree.SubElement(Envelope, "{%s}lowerCorner" % ns_gml)
    # lowercorner.text = '0 0 0'
    # uppercorner = etree.SubElement(Envelope, "{%s}upperCorner" % ns_gml)
    # uppercorner.text = '4000 4000 25'
    return CityModel


def storeCityGML(CityGMLs,suffix):
    "Write the CityGML file."
    citygml = etree.tostring(CityGMLs[suffix], pretty_print=True)
    #-- Write the CityGML file
    if str(suffix) == 'Ground Truth':
        fname = DIRECTORY + '/' + 'groundTruth.gml'
    else:
        fname = DIRECTORY + '/' + str(suffix) + '.gml'
    citygmlFile = open(fname, "w")
    #-- Header of the XML
    citygmlFile.write("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n")
    citygmlFile.write("<!-- Generated by Random3Dcity (http://github.com/tudelft3d/Random3Dcity), a tool developed by Filip Biljecki at TU Delft. Version: 2015-03-11. -->\n")
    # citygmlFile.write(citygml)
    citygmlFile.write(citygml.decode('utf-8'))
    citygmlFile.close()



class Building(object):
    def __init__(self, xml, id):
        #-- ID of the building
        self.id = id
        #-- XML tree of the building
        self.xml = xml
        #-- Data for each roof surface required for the computation of the solar stuff
        self.roofdata = {}
        #-- List of IDs of openings, not to mess with usable roof surfaces
        self.listOfOpenings = []
        #-- Compute the total areas of surfaces per semantic class (not really required; reserved for future use)
        #-- RoofSurface
        # self.RoofSurfaceArea = self.roofarea()
        #-- WallSurface
        # self.WallSurfaceArea = self.wallarea()
        self.posinformation=self.posext()
        self.imageinformation=self.imageext()

    
    def posext(self):
        """The total area of WallSurfaces."""
        self.walls = []
        self.wallsurfaces = []
        # wallarea = 0.0
        # openings = 0.0
        self.poslistset={}
        self.area=[]
        self.posid=[]
        self.pospos=[]
        #-- Account for openings
        for child in self.xml.getiterator():
            if child.tag == '{%s}WallSurface' %ns_bldg:
                self.walls.append(child)
                # openings += oparea(child)
        for surface in self.walls:
            for a in surface.findall('.//{%s}doubleAttribute' %ns_gen):
                if a.attrib['name'] == 'Area':
                    ar=a.find('.//{%s}value' %ns_gen)
                    self.area.append(ar)
            for w in surface.findall('.//{%s}Polygon' %ns_gml):
                self.wallsurfaces.append(w)
            
        # for wallsurface in self.wallsurfaces:
                for child in w.getiterator():
                    if child.tag == '{%s}LinearRing' %ns_gml:
                        # print (child.attrib['{%s}id' %ns_gml])
                        # self.pospos.append(child)
                        # self.posid.append(child.attrib['{%s}id' %ns_gml])
                        self.poslistset[child.attrib['{%s}id' %ns_gml]]={'pos': child.find('.//{%s}posList' %ns_gml)}#,'area': ar}
        
        # self.poslistset['id']=self.posid
        # self.poslistset['pos']=self.pospos
        
        return self.poslistset
    
    def imageext(self):
        """"extracting image information, which contains id, coordinates, name"""
        self.imageinfset={}
        self.app=[]
        self.appsurf=[]
        # self.imageid=[]
        self.imagename=[]
        self.imagecoordinates=[]
        for child in self.xml.getiterator():
            if child.tag == '{%s}surfaceDataMember' %ns_app:
                self.app.append(child)
                self.imagename.append(child.find('.//{%s}imageURI' %ns_app))
                
        # for surface in self.app:
                for w in child.findall('.//{%s}target' %ns_app):
                    self.appsurf.append(w)
                
                    # for imsurf in self.appsurf:
                    for child2 in w.getiterator():
                        if child2.tag == '{%s}TexCoordList' %ns_app:
                            # print (child.attrib['{%s}id' %ns_gml])
                            self.imageinfset[child2.find('.//{%s}textureCoordinates' %ns_app).attrib['ring'][1:]]={'coord':child2.find('.//{%s}textureCoordinates' %ns_app),'imgname':child.find('.//{%s}imageURI' %ns_app)}

        return self.imageinfset
    
def point2str(vertex):
    s = ''
    for x,y,z in vertex:
        s += str(x)+' '
        s += str(y)+' '
        s += str(z)+' '
    
    return s.strip()

def counterclockwise_old(poslists,innerpoint = None,label = None):
    modelpts = coor_opening4.transpos(poslists)
    newmp=[]
    # zs=[]
    for x,y,z in modelpts:
        newmp.append((x,z))
        # newmp.append((np.sqrt(x+y),z))
        # zs.append(z)
    newmp=np.array(newmp)
    s = newmp.sum(axis = 1)
    x1,y1,z1 = modelpts[np.argmin(s)]
    x2,y2,z2 = modelpts[np.argmax(s)]
    mins = np.argmin(s)
    maxs = np.argmax(s)
    if innerpoint:
        if maxs>mins:
            vector1 = (innerpoint[0]-x1,innerpoint[1]-y1)
            vector2 = (x2-x1,y2-y1)
            cross = np.cross(vector1,vector2)
            if label:
                if cross > 0:
                    # print ('counterclockwise')
                    return poslists
                else:
                    # print ('clockwise')
                    newlist = []
                    lenth = len(modelpts)
                    for i in range(lenth):
                        newlist.append(modelpts[lenth-1-i])
                    newposlists = point2str(newlist)
                    
                    return newposlists
            else:
                if cross < 0:
                    # print ('counterclockwise')
                    return poslists
                else:
                    # print ('clockwise')
                    newlist = []
                    lenth = len(modelpts)
                    for i in range(lenth):
                        newlist.append(modelpts[lenth-1-i])
                    newposlists = point2str(newlist)
                    
                    return newposlists
        else:
            vector1 = (innerpoint[0]-x2,innerpoint[1]-y2)
            vector2 = (x1-x2,y1-y2)
            cross = np.cross(vector1,vector2)
            if label:
                if cross > 0:
                    # print ('counterclockwise')
                    return poslists
                else:
                    # print ('clockwise')
                    newlist = []
                    lenth = len(modelpts)
                    for i in range(lenth):
                        newlist.append(modelpts[lenth-1-i])
                    newposlists = point2str(newlist)
                    
                    return newposlists
            else:
                if cross < 0:
                    # print ('counterclockwise')
                    return poslists
                else:
                    # print ('clockwise')
                    newlist = []
                    lenth = len(modelpts)
                    for i in range(lenth):
                        newlist.append(modelpts[lenth-1-i])
                    newposlists = point2str(newlist)
                    
                    return newposlists
    else:
        return poslists
    
    # else:
    #     angle_of_rotation = math.atan((y2-y1)/((x2-x1)+0.001))
    #     # print (count)
    #     if label:
    #         if angle_of_rotation < 0:
    #             # print ('counterclockwise')
    #             return poslists
    #         else:
    #             # print ('clockwise')
    #             newlist = []
    #             lenth = len(modelpts)
    #             for i in range(lenth):
    #                 newlist.append(modelpts[lenth-1-i])
    #             newposlists = point2str(newlist)
                
    #             return newposlists
    #     else:
    #         if angle_of_rotation >= 0:
    #             # print ('counterclockwise')
    #             return poslists
    #         else:
    #             # print ('clockwise')
    #             newlist = []
    #             lenth = len(modelpts)
    #             for i in range(lenth):
    #                 newlist.append(modelpts[lenth-1-i])
    #             newposlists = point2str(newlist)
                
    #             return newposlists
def counterclockwise(poslists,innerpoint = None,label = None):
    
    modelpts = coor_opening4.transpos(poslists)
    def invers(modelpts):
        newlist = []
        lenth = len(modelpts)
        for i in range(lenth):
            newlist.append(modelpts[lenth-1-i])
        # newposlists = point2str(newlist)
        
        return newlist


    newmp=[]
    # zs=[]
    for x,y,z in modelpts:
        newmp.append((x,z))
        # newmp.append((np.sqrt(x+y),z))
        # zs.append(z)
    newmp=np.array(newmp)
    # s = newmp.sum(axis = 1)
    # print (modelpts[0],innerpoint)
    if innerpoint:
        vector1 = np.array(modelpts[0]) - innerpoint
        vector2 = np.array(modelpts[1]) - innerpoint
        
        cross = np.cross(vector1, vector2)
        
        if label == "RoofSurface":
            # print ('cross',cross[2])
            if cross[2] >= 0:
                return point2str(modelpts)
            else:
                return point2str(invers(modelpts))
        
        if label == "GroundSurface":
            if cross[2] < 0:
                return point2str(modelpts)
            else:
                return point2str(invers(modelpts))
        if label == "WallSurface":
            # if innerpoint:
            binner = np.array(modelpts)
            innerpoint2 = np.array(list(sum(binner)/len(binner)))
            vector1 = np.array(modelpts[0]) - innerpoint2
            vector2 = np.array(modelpts[1]) - innerpoint2
            cross = np.cross(vector1, vector2)
            
            innerdirect = innerpoint2 - np.array(innerpoint)
            # direction = np.multiply(cross,innerdirect)
            # if all(direction[0:2]>=0):
            direction = np.dot(cross,innerdirect)
            if direction > 0:
                
                return point2str(modelpts)
            else:
                return point2str(invers(modelpts))
            
        if label == "opening":
            # if innerpoint:
            binner = np.array(modelpts)
            innerpoint2 = np.array(list(sum(binner)/len(binner)))
            vector1 = np.array(modelpts[0]) - innerpoint2
            vector2 = np.array(modelpts[1]) - innerpoint2
            cross = np.cross(vector1, vector2)
            
            innerdirect = innerpoint2 - np.array(innerpoint)
            # direction = np.multiply(cross,innerdirect)
            # if all(direction[0:2]<=0):
            direction = np.dot(cross,innerdirect)
            if direction<=0:
                return point2str(modelpts)
            else:
                return point2str(invers(modelpts))
    else:
        return poslists
    
# def multiSurfaceWithEmbrasure(bldg, child, semantics,opening=None, innerpoint=None, LOD=None, embO=None):
#     """
#     Write a surface with input coordinates, taking into account the embrasures.
#     Input: coordinates of the LinearRing.
#     Output: CompositeSurface.
#     """
    
#     boundedBy = etree.SubElement(bldg, "{%s}boundedBy" % ns_bldg)
    
#     ssf = child.find("{%s}%s" % (ns_bldg, semantics))
#     wfid = ssf.attrib['{%s}id' %ns_gml]
#     # print (wfid)
#     semanticSurface = etree.SubElement(boundedBy, "{%s}%s" % (ns_bldg, semantics))
#     semanticSurface.attrib['{%s}id' % ns_gml] = wfid
    
#     lodX = ssf.find("{%s}lod2MultiSurface" % ns_bldg)
#     lodXMultiSurface = etree.SubElement(semanticSurface, "{%s}lod3MultiSurface" % ns_bldg)
    
#     mlt = lodX.find("{%s}MultiSurface" % ns_gml)
#     mltid = mlt.attrib['{%s}id' %ns_gml]
#     MultiSurface = etree.SubElement(lodXMultiSurface, "{%s}MultiSurface" % ns_gml)
#     MultiSurface.attrib['{%s}id' % ns_gml] = mltid
        
#     # sf = mlt.find("{%s}surfaceMember" % ns_gml)
#     surfaceMember = etree.SubElement(MultiSurface, "{%s}surfaceMember" % ns_gml)
    
#     CompositeSurface = etree.SubElement(surfaceMember, "{%s}CompositeSurface" % ns_gml)
#     CompositeSurface.attrib['{%s}id' % ns_gml] = "GML_"+str(uuid.uuid4())
#     plyidset = [wfid]
#     for sf in mlt.findall("{%s}surfaceMember" % ns_gml):
#         # print (mltid,sf)
#         # sfid = sf.attrib['{%s}id' % ns_gml]
#         subsurfaceMember = etree.SubElement(CompositeSurface, "{%s}surfaceMember" % ns_gml)
#         # subsurfaceMember.attrib['{%s}id' % ns_gml] = sfid
#         plg = sf.find("{%s}Polygon" % ns_gml)
#         plyid = plg.attrib['{%s}id' %ns_gml]
#         Polygon = etree.SubElement(subsurfaceMember, "{%s}Polygon" % ns_gml)
#         Polygon.attrib['{%s}id' % ns_gml] = plyid
#         plyidset.append(plyid)
        
#         ext = plg.find("{%s}exterior" % ns_gml)
#         PolygonExterior = etree.SubElement(Polygon, "{%s}exterior" % ns_gml)
        
#         lring = ext.find("{%s}LinearRing" % ns_gml)
#         lringid = lring.attrib['{%s}id' %ns_gml]
#         LinearRing = etree.SubElement(PolygonExterior, "{%s}LinearRing" % ns_gml)
#         LinearRing.attrib['{%s}id' % ns_gml] = lringid
        
#         plist = lring.find('{%s}posList' %ns_gml)
#         # plistid = plist.attrib['srsDimension="3"']
#         posList = etree.SubElement(LinearRing, "{%s}posList" % ns_gml)
#         posList.attrib['srsDimension'] = "3"
#         poslistext = counterclockwise(plist.text,innerpoint, semantics)
        
#         posList.text = poslistext
        
#         if opening:
#             for label in opening.keys():
#                 if len(opening[label]) > 0:
#                     for entity in opening[label]:
#                         gmlopening = etree.SubElement(semanticSurface, "{%s}opening" % ns_bldg)
#                         if label != 'balcony':    
#                             if label == 'window':
#                                 label = 'Window'
#                             if label == 'door':
#                                 label = 'Door'
#                             entityopening = etree.SubElement(gmlopening, "{%s}%s" % (ns_bldg, label))
#                             lod3MultiSurface = etree.SubElement(entityopening, "{%s}lod3MultiSurface" % ns_bldg)
#                             entityMultiSurface = etree.SubElement(lod3MultiSurface, "{%s}MultiSurface" % ns_gml)
#                             entitysurfaceMember = etree.SubElement(entityMultiSurface, "{%s}surfaceMember" % ns_gml)
#                             entityPolygon = etree.SubElement(entitysurfaceMember, "{%s}Polygon" % ns_gml)
                
#                             # entityPolygon.attrib['{%s}id' % ns_gml] = "BID_"+str(uuid.uuid4())
                            
#                             entityPolygonExterior = etree.SubElement(entityPolygon, "{%s}exterior" % ns_gml)
#                             entityLinearRing = etree.SubElement(entityPolygonExterior, "{%s}LinearRing" % ns_gml)
#                             entityLinearRing.attrib['{%s}id' % ns_gml] = "BID_"+str(uuid.uuid4())
                            
#                             entityposList = etree.SubElement(entityLinearRing, "{%s}posList" % ns_gml)
#                             entityposList.attrib['srsDimension'] = "3"
#                             # o = point2str(entity[0])
#                             # entityposList.text = o#['ring']
#                             o = point2str(entity[0])
#                             entitytext = counterclockwise(o,innerpoint,'opening')
#                             # print ('entitytext',entitytext)
                            
#                             entityposList.text = entitytext#['ring']
                            
#                             # DIG HOLES
#                             if opening != None :
#                                 Polygoninterior = etree.SubElement(Polygon, "{%s}interior" % ns_gml)
                
#                                 # lring = ext.find("{%s}LinearRing" % ns_gml)
#                                 # lringid = lring.attrib['{%s}id' %ns_gml]
#                                 LinearRing = etree.SubElement(Polygoninterior, "{%s}LinearRing" % ns_gml)
#                                 LinearRing.attrib['{%s}id' % ns_gml] = "BID_"+str(uuid.uuid4())
                                
#                                 # plist = lring.find('{%s}posList' %ns_gml)
#                                 # plistid = plist.attrib['srsDimension="3"']
#                                 itnposList = etree.SubElement(LinearRing, "{%s}posList" % ns_gml)
#                                 itnposList.attrib['srsDimension'] = "3"
#                                 itn = point2str(entity[4])
#                                 # itn = counterclockwise(itn, innerpoint, label= "opening")#counterclockwise(itn,innerpoint,label='window')
#                                 itnposList.text = itn
#                                 # entitytext4 = counterclockwise(entity[4],innerpoint,'opening')
#                                 # # o = point2str(entitytext)
#                                 # itn = point2str(entitytext4)
#                                 # itnposList.text = itn
                                
                            
#                         else:
#                             obi = etree.SubElement(bldg, "{%s}outerBuildingInstallation" % ns_bldg)
#                             bi = etree.SubElement(obi, "{%s}BuildingInstallation" % ns_bldg)
#                             bb = etree.SubElement(bi, "{%s}boundedBy" % ns_bldg)
#                             cs = etree.SubElement(bb, "{%s}ClosureSurface" % ns_bldg)
#                             lod3MultiSurface = etree.SubElement(cs, "{%s}lod3MultiSurface" % ns_bldg)
#                             balcMultiSurface = etree.SubElement(lod3MultiSurface, "{%s}MultiSurface" % ns_gml)
#                             balcsurfaceMember = etree.SubElement(balcMultiSurface, "{%s}surfaceMember" % ns_gml)
#                             balcPolygon = etree.SubElement(balcsurfaceMember, "{%s}Polygon" % ns_gml)
#                             balcPolygonExterior = etree.SubElement(balcPolygon, "{%s}exterior" % ns_gml)
#                             balcLinearRing = etree.SubElement(balcPolygonExterior, "{%s}LinearRing" % ns_gml)
#                             balcLinearRing.attrib['{%s}id' % ns_gml] = "BID_"+str(uuid.uuid4())
#                             balcposList = etree.SubElement(balcLinearRing, "{%s}posList" % ns_gml)
#                             balcposList.attrib['srsDimension'] = "3"
#                             balc = point2str(entity[0])
#                             balcposList.text = balc
                        
#     return plyidset

def multiSurfaceWithEmbrasure(semanticSurface, Polygon, semantics,opening=None, innerpoint=None, LOD=None, embO=None):
    """
    Write a surface with input coordinates, taking into account the embrasures.
    Input: coordinates of the LinearRing.
    Output: CompositeSurface.
    """
    
    plyidset = []
        
    if opening:
        for label in opening.keys():
            if len(opening[label]) > 0:
                for entity in opening[label]:
                    gmlopening = etree.SubElement(semanticSurface, "{%s}opening" % ns_bldg)
                    if label != 'balcony':    
                        if label == 'window':
                            label = 'Window'
                        if label == 'door':
                            label = 'Door'
                        entityopening = etree.SubElement(gmlopening, "{%s}%s" % (ns_bldg, label))
                        lod3MultiSurface = etree.SubElement(entityopening, "{%s}lod3MultiSurface" % ns_bldg)
                        entityMultiSurface = etree.SubElement(lod3MultiSurface, "{%s}MultiSurface" % ns_gml)
                        entitysurfaceMember = etree.SubElement(entityMultiSurface, "{%s}surfaceMember" % ns_gml)
                        entityPolygon = etree.SubElement(entitysurfaceMember, "{%s}Polygon" % ns_gml)
            
                        # entityPolygon.attrib['{%s}id' % ns_gml] = "BID_"+str(uuid.uuid4())
                        
                        entityPolygonExterior = etree.SubElement(entityPolygon, "{%s}exterior" % ns_gml)
                        entityLinearRing = etree.SubElement(entityPolygonExterior, "{%s}LinearRing" % ns_gml)
                        entityLinearRing.attrib['{%s}id' % ns_gml] = "BID_"+str(uuid.uuid4())
                        
                        entityposList = etree.SubElement(entityLinearRing, "{%s}posList" % ns_gml)
                        entityposList.attrib['srsDimension'] = "3"
                        # o = point2str(entity[0])
                        # entityposList.text = o#['ring']
                        o = point2str(entity[0])
                        entitytext = counterclockwise(o,innerpoint,'opening')
                        # print ('entitytext',entitytext)
                        
                        entityposList.text = entitytext#['ring']
                        
                        # DIG HOLES
                        if opening != None :
                            Polygoninterior = etree.SubElement(Polygon, "{%s}interior" % ns_gml)
            
                            # lring = ext.find("{%s}LinearRing" % ns_gml)
                            # lringid = lring.attrib['{%s}id' %ns_gml]
                            LinearRing = etree.SubElement(Polygoninterior, "{%s}LinearRing" % ns_gml)
                            LinearRing.attrib['{%s}id' % ns_gml] = "BID_"+str(uuid.uuid4())
                            
                            # plist = lring.find('{%s}posList' %ns_gml)
                            # plistid = plist.attrib['srsDimension="3"']
                            itnposList = etree.SubElement(LinearRing, "{%s}posList" % ns_gml)
                            itnposList.attrib['srsDimension'] = "3"
                            itn = point2str(entity[4])
                            # itn = counterclockwise(itn, innerpoint, label= "opening")#counterclockwise(itn,innerpoint,label='window')
                            itnposList.text = itn
                            # entitytext4 = counterclockwise(entity[4],innerpoint,'opening')
                            # # o = point2str(entitytext)
                            # itn = point2str(entitytext4)
                            # itnposList.text = itn
                            
                        
                    # else:
                    #     obi = etree.SubElement(bldg, "{%s}outerBuildingInstallation" % ns_bldg)
                    #     bi = etree.SubElement(obi, "{%s}BuildingInstallation" % ns_bldg)
                    #     bb = etree.SubElement(bi, "{%s}boundedBy" % ns_bldg)
                    #     cs = etree.SubElement(bb, "{%s}ClosureSurface" % ns_bldg)
                    #     lod3MultiSurface = etree.SubElement(cs, "{%s}lod3MultiSurface" % ns_bldg)
                    #     balcMultiSurface = etree.SubElement(lod3MultiSurface, "{%s}MultiSurface" % ns_gml)
                    #     balcsurfaceMember = etree.SubElement(balcMultiSurface, "{%s}surfaceMember" % ns_gml)
                    #     balcPolygon = etree.SubElement(balcsurfaceMember, "{%s}Polygon" % ns_gml)
                    #     balcPolygonExterior = etree.SubElement(balcPolygon, "{%s}exterior" % ns_gml)
                    #     balcLinearRing = etree.SubElement(balcPolygonExterior, "{%s}LinearRing" % ns_gml)
                    #     balcLinearRing.attrib['{%s}id' % ns_gml] = "BID_"+str(uuid.uuid4())
                    #     balcposList = etree.SubElement(balcLinearRing, "{%s}posList" % ns_gml)
                    #     balcposList.attrib['srsDimension'] = "3"
                    #     balc = point2str(entity[0])
                    #     balcposList.text = balc
                        
    return plyidset


def lodsolid(bldg,exist=True, child = None,plyidset=None):
    
    # print (child)
    if exist == True:
        sd = child.find('{%s}Solid' %ns_gml)
        sdid = sd.attrib['{%s}id' %ns_gml]
        lod3Solid = etree.SubElement(bldg, "{%s}lod3Solid" % ns_bldg)
        solid = etree.SubElement(lod3Solid, "{%s}Solid" % ns_gml)
        solid.attrib['{%s}id' % ns_gml] = sdid
        
        ext = sd.find('{%s}exterior' %ns_gml)
        exterior = etree.SubElement(solid, "{%s}exterior" % ns_gml)
        
        comps = ext.find('{%s}CompositeSurface' %ns_gml)
        compsid = comps.attrib['{%s}id' %ns_gml]
        CompositeSurface = etree.SubElement(exterior, "{%s}CompositeSurface" % ns_gml)
        CompositeSurface.attrib['{%s}id' % ns_gml] = compsid
    
        for surfaceMember in comps.findall('.//{%s}surfaceMember' %ns_gml):
            smlink = surfaceMember.attrib['{%s}href' %ns_xlink]
            surfaceMember = etree.SubElement(CompositeSurface, "{%s}surfaceMember" % ns_gml)
            surfaceMember.attrib['{%s}href' %ns_xlink] = smlink
    else:
        lod3Solid = etree.SubElement(bldg, "{%s}lod3Solid" % ns_bldg)
        solid = etree.SubElement(lod3Solid, "{%s}Solid" % ns_gml)
        exterior = etree.SubElement(solid, "{%s}exterior" % ns_gml)
        CompositeSurface = etree.SubElement(exterior, "{%s}CompositeSurface" % ns_gml)
        for plysemantic in plyidset:
            for plyid in plysemantic:
                surfaceMember = etree.SubElement(CompositeSurface, "{%s}surfaceMember" % ns_gml)
                surfaceMember.attrib['{%s}href' %ns_xlink] = plyid

def calinnerpoint(lc,uc):
    lc = coor_opening4.transpos(lc)[0]
    uc = coor_opening4.transpos(uc)[0]
    return ((lc[0]+uc[0])/2,(lc[1]+uc[1])/2,(lc[2]+uc[2])/2)

def wallface(b, bldg, bldinf, rel_model, para_path):
    
    if b.find("{%s}boundedBy" % ns_gml) is not None:
        # if child.find("{%s}Envelope" % ns_gml) is not None:
        print ('Envelope')
        bd = b.find("{%s}boundedBy" % ns_gml)
        
        elop = bd.find('{%s}Envelope' %ns_gml)
        srsname = elop.attrib['srsName']
        # smlink = surfaceMember.attrib['{%s}href' %ns_xlink]
        boundedBy = etree.SubElement(bldg, "{%s}boundedBy" % ns_gml)
        Envelope = etree.SubElement(boundedBy, "{%s}Envelope" % ns_gml)
        Envelope.attrib['srsName'] = srsname
        Envelope.attrib['srsDimension'] = "3"
        lc = elop.find('{%s}lowerCorner' %ns_gml)
        # plistid = plist.attrib['srsDimension="3"']
        lowercorner = etree.SubElement(Envelope, "{%s}lowerCorner" % ns_gml)
        lowercorner.text = lc.text
        uc = elop.find('{%s}upperCorner' %ns_gml)
        # plistid = plist.attrib['srsDimension="3"']
        uppercorner = etree.SubElement(Envelope, "{%s}upperCorner" % ns_gml)
        uppercorner.text = uc.text
        innerpoint = calinnerpoint(lc.text,uc.text)
    
    plyidsetw,plyidsetr,plyidsetg = [],[],[]
    for child in b.findall('{%s}boundedBy' %ns_bldg):
        # if child.tag == '{%s}boundedBy' %ns_bldg:
        if child.find('{%s}WallSurface' %ns_bldg) is not None:
            # print ('wallface')
            
            
            boundedBy = etree.SubElement(bldg, "{%s}boundedBy" % ns_bldg)
                
            ssf = child.find("{%s}%s" % (ns_bldg, "WallSurface"))
            wfid = ssf.attrib['{%s}id' %ns_gml]
            # print (wfid)
            semanticSurface = etree.SubElement(boundedBy, "{%s}%s" % (ns_bldg, "WallSurface"))
            semanticSurface.attrib['{%s}id' % ns_gml] = wfid
            
            lodX = ssf.find("{%s}lod2MultiSurface" % ns_bldg)
            lodXMultiSurface = etree.SubElement(semanticSurface, "{%s}lod3MultiSurface" % ns_bldg)
            
            mlt = lodX.find("{%s}MultiSurface" % ns_gml)
            mltid = mlt.attrib['{%s}id' %ns_gml]
            MultiSurface = etree.SubElement(lodXMultiSurface, "{%s}MultiSurface" % ns_gml)
            MultiSurface.attrib['{%s}id' % ns_gml] = mltid
                
            # sf = mlt.find("{%s}surfaceMember" % ns_gml)
            surfaceMember = etree.SubElement(MultiSurface, "{%s}surfaceMember" % ns_gml)
            
            CompositeSurface = etree.SubElement(surfaceMember, "{%s}CompositeSurface" % ns_gml)
            CompositeSurface.attrib['{%s}id' % ns_gml] = "GML_"+str(uuid.uuid4())
            plyidset = [wfid]
            for sf in mlt.findall("{%s}surfaceMember" % ns_gml):
                # print (mltid,sf)
                # sfid = sf.attrib['{%s}id' % ns_gml]
                subsurfaceMember = etree.SubElement(CompositeSurface, "{%s}surfaceMember" % ns_gml)
                # subsurfaceMember.attrib['{%s}id' % ns_gml] = sfid
                plg = sf.find("{%s}Polygon" % ns_gml)
                plyid = plg.attrib['{%s}id' %ns_gml]
                Polygon = etree.SubElement(subsurfaceMember, "{%s}Polygon" % ns_gml)
                Polygon.attrib['{%s}id' % ns_gml] = plyid
                plyidset.append(plyid)
                
                ext = plg.find("{%s}exterior" % ns_gml)
                PolygonExterior = etree.SubElement(Polygon, "{%s}exterior" % ns_gml)
                
                lring = ext.find("{%s}LinearRing" % ns_gml)
                lringid = lring.attrib['{%s}id' %ns_gml]
                LinearRing = etree.SubElement(PolygonExterior, "{%s}LinearRing" % ns_gml)
                LinearRing.attrib['{%s}id' % ns_gml] = lringid
                
                plist = lring.find('{%s}posList' %ns_gml)
                # plistid = plist.attrib['srsDimension="3"']
                posList = etree.SubElement(LinearRing, "{%s}posList" % ns_gml)
                posList.attrib['srsDimension'] = "3"
                poslistext = counterclockwise(plist.text,innerpoint, "WallSurface")
                
                posList.text = poslistext
                
            # childwall = child.find('{%s}WallSurface' %ns_bldg)
            # # for child2 in childwall.findall("{%s}lod2MultiSurface" % ns_bldg): #.getiterator():
            # # child2 = childwall.find("{%s}lod2MultiSurface" % ns_bldg)
            #     # print ('child2')
            # for child3 in childwall.getiterator():
            #     # print (child3.tag)
            #     if child3.tag == "{%s}LinearRing" % ns_gml:
            #         lringid = child3.attrib['{%s}id' %ns_gml]
                    
                if lringid in rel_model.keys():
                    
                    LinearRing = bldinf.posinformation[lringid]['pos'].text
                    modelpts = transpos(LinearRing)
                    imgpath = rel_model[lringid]['img']
                    imgname = imgpath.split('/')[-1].split('.')[0]
                    para = joblib.load(para_path+'/'+imgname+'.'+'pkl')
                    modelinf = coor_opening4.get_coord(para, modelpts)
                    # print (imgname)
                    plyidsetw = multiSurfaceWithEmbrasure(semanticSurface,Polygon,"WallSurface", modelinf, innerpoint)
                    
                # else:
                #     modelinf = None
                #     plyidsetw = multiSurfaceWithEmbrasure(bldg, child, "WallSurface")
                    # print (modelinf)
                    # plyidsetw = multiSurfaceWithEmbrasure(bldg,child,"WallSurface", modelinf, innerpoint)
                    # break

        if child.find('{%s}RoofSurface' %ns_bldg) is not None:
            # print ('RoofSurface')
            boundedBy = etree.SubElement(bldg, "{%s}boundedBy" % ns_bldg)
                
            ssf = child.find("{%s}%s" % (ns_bldg, "RoofSurface"))
            wfid = ssf.attrib['{%s}id' %ns_gml]
            # print (wfid)
            semanticSurface = etree.SubElement(boundedBy, "{%s}%s" % (ns_bldg, "RoofSurface"))
            semanticSurface.attrib['{%s}id' % ns_gml] = wfid
            
            lodX = ssf.find("{%s}lod2MultiSurface" % ns_bldg)
            lodXMultiSurface = etree.SubElement(semanticSurface, "{%s}lod3MultiSurface" % ns_bldg)
            
            mlt = lodX.find("{%s}MultiSurface" % ns_gml)
            mltid = mlt.attrib['{%s}id' %ns_gml]
            MultiSurface = etree.SubElement(lodXMultiSurface, "{%s}MultiSurface" % ns_gml)
            MultiSurface.attrib['{%s}id' % ns_gml] = mltid
                
            # sf = mlt.find("{%s}surfaceMember" % ns_gml)
            surfaceMember = etree.SubElement(MultiSurface, "{%s}surfaceMember" % ns_gml)
            
            CompositeSurface = etree.SubElement(surfaceMember, "{%s}CompositeSurface" % ns_gml)
            CompositeSurface.attrib['{%s}id' % ns_gml] = "GML_"+str(uuid.uuid4())
            plyidsetr = [wfid]
            for sf in mlt.findall("{%s}surfaceMember" % ns_gml):
                # print (mltid,sf)
                # sfid = sf.attrib['{%s}id' % ns_gml]
                subsurfaceMember = etree.SubElement(CompositeSurface, "{%s}surfaceMember" % ns_gml)
                # subsurfaceMember.attrib['{%s}id' % ns_gml] = sfid
                plg = sf.find("{%s}Polygon" % ns_gml)
                plyid = plg.attrib['{%s}id' %ns_gml]
                Polygon = etree.SubElement(subsurfaceMember, "{%s}Polygon" % ns_gml)
                Polygon.attrib['{%s}id' % ns_gml] = plyid
                plyidsetr.append(plyid)
                
                ext = plg.find("{%s}exterior" % ns_gml)
                PolygonExterior = etree.SubElement(Polygon, "{%s}exterior" % ns_gml)
                
                lring = ext.find("{%s}LinearRing" % ns_gml)
                lringid = lring.attrib['{%s}id' %ns_gml]
                LinearRing = etree.SubElement(PolygonExterior, "{%s}LinearRing" % ns_gml)
                LinearRing.attrib['{%s}id' % ns_gml] = lringid
                
                plist = lring.find('{%s}posList' %ns_gml)
                # plistid = plist.attrib['srsDimension="3"']
                posList = etree.SubElement(LinearRing, "{%s}posList" % ns_gml)
                posList.attrib['srsDimension'] = "3"
                poslistext = counterclockwise(plist.text,innerpoint, "RoofSurface")
                
                posList.text = poslistext
                # plyidsetr = multiSurfaceWithEmbrasure(semanticSurface,Polygon, "RoofSurface")

        if child.find('{%s}GroundSurface' %ns_bldg) is not None:
            # print ('GroundSurface')
            boundedBy = etree.SubElement(bldg, "{%s}boundedBy" % ns_bldg)
                
            ssf = child.find("{%s}%s" % (ns_bldg, "GroundSurface"))
            wfid = ssf.attrib['{%s}id' %ns_gml]
            # print (wfid)
            semanticSurface = etree.SubElement(boundedBy, "{%s}%s" % (ns_bldg, "GroundSurface"))
            semanticSurface.attrib['{%s}id' % ns_gml] = wfid
            
            lodX = ssf.find("{%s}lod2MultiSurface" % ns_bldg)
            lodXMultiSurface = etree.SubElement(semanticSurface, "{%s}lod3MultiSurface" % ns_bldg)
            
            mlt = lodX.find("{%s}MultiSurface" % ns_gml)
            mltid = mlt.attrib['{%s}id' %ns_gml]
            MultiSurface = etree.SubElement(lodXMultiSurface, "{%s}MultiSurface" % ns_gml)
            MultiSurface.attrib['{%s}id' % ns_gml] = mltid
                
            # sf = mlt.find("{%s}surfaceMember" % ns_gml)
            surfaceMember = etree.SubElement(MultiSurface, "{%s}surfaceMember" % ns_gml)
            
            CompositeSurface = etree.SubElement(surfaceMember, "{%s}CompositeSurface" % ns_gml)
            CompositeSurface.attrib['{%s}id' % ns_gml] = "GML_"+str(uuid.uuid4())
            plyidsetg = [wfid]
            for sf in mlt.findall("{%s}surfaceMember" % ns_gml):
                # print (mltid,sf)
                # sfid = sf.attrib['{%s}id' % ns_gml]
                subsurfaceMember = etree.SubElement(CompositeSurface, "{%s}surfaceMember" % ns_gml)
                # subsurfaceMember.attrib['{%s}id' % ns_gml] = sfid
                plg = sf.find("{%s}Polygon" % ns_gml)
                plyid = plg.attrib['{%s}id' %ns_gml]
                Polygon = etree.SubElement(subsurfaceMember, "{%s}Polygon" % ns_gml)
                Polygon.attrib['{%s}id' % ns_gml] = plyid
                plyidsetg.append(plyid)
                
                ext = plg.find("{%s}exterior" % ns_gml)
                PolygonExterior = etree.SubElement(Polygon, "{%s}exterior" % ns_gml)
                
                lring = ext.find("{%s}LinearRing" % ns_gml)
                lringid = lring.attrib['{%s}id' %ns_gml]
                LinearRing = etree.SubElement(PolygonExterior, "{%s}LinearRing" % ns_gml)
                LinearRing.attrib['{%s}id' % ns_gml] = lringid
                
                plist = lring.find('{%s}posList' %ns_gml)
                # plistid = plist.attrib['srsDimension="3"']
                posList = etree.SubElement(LinearRing, "{%s}posList" % ns_gml)
                posList.attrib['srsDimension'] = "3"
                poslistext = counterclockwise(plist.text,innerpoint, "GroundSurface")
                
                posList.text = poslistext
                # plyidsetg = multiSurfaceWithEmbrasure(semanticSurface,Polygon, "GroundSurface")
        
    
    
    plyidsets = [plyidsetw,plyidsetr,plyidsetg]
    if b.find('{%s}lod2Solid' %ns_bldg) is not None:
        childsolid = b.find('{%s}lod2Solid' %ns_bldg)
        lodsolid(bldg, True, childsolid)
                
    else:
        childsolid = None
        lodsolid(bldg, False, childsolid, plyidsets)
        
def addmateiral(appmemb, semanticmaterialsets):
    Appearance = etree.SubElement(appmemb, "{%s}Appearance" % ns_app)
    def title(Appearance):
        
        surface = etree.SubElement(Appearance, "{%s}surfaceDataMember" % ns_app)
        X3D = etree.SubElement(surface, "{%s}X3DMaterial" % ns_app)
        return X3D
    for sm in semanticmaterialsets:
        # print ('smkey', list(sm.keys()))
        if list(sm.keys()) != ['roof']:
            for i in list(sm.keys()):
                if i == 'Window':
                    X3D = title(Appearance)
                    X3D.attrib['{%s}id' % ns_gml] = "windowMaterial"
                    diffcolor =  etree.SubElement(X3D, "{%s}diffuseColor" % ns_app)
                    diffcolor.text = "0.0 1.0 1.0"
                    for tar in sm[i]:
                        target =  etree.SubElement(X3D, "{%s}target" % ns_app)
                        target.text = tar
                elif i == "Door":
                    X3D = title(Appearance)
                    X3D.attrib['{%s}id' % ns_gml] = "doorMaterial"
                    diffcolor =  etree.SubElement(X3D, "{%s}diffuseColor" % ns_app)
                    diffcolor.text = "0.0 0.0 1.0"
                    for tar in sm[i]:
                        target =  etree.SubElement(X3D, "{%s}target" % ns_app)
                        target.text = tar
                elif i == "wall":
                    X3D = title(Appearance)
                    X3D.attrib['{%s}id' % ns_gml] = "wallMaterial"
                    diffcolor =  etree.SubElement(X3D, "{%s}diffuseColor" % ns_app)
                    diffcolor.text = "0.57 0.64 0.69"
                    for tar in sm[i]:
                        target =  etree.SubElement(X3D, "{%s}target" % ns_app)
                        target.text = tar
        elif list(sm.keys()) == ["roof"]:
            X3D = title(Appearance)
            X3D.attrib['{%s}id' % ns_gml] = "roofMaterial"
            diffcolor =  etree.SubElement(X3D, "{%s}diffuseColor" % ns_app)
            diffcolor.text = "0.0 1.0 1.0"
            for tar in sm.values():
                target =  etree.SubElement(X3D, "{%s}target" % ns_app)
                target.text = tar        
                

                

def CityGMLbuildingLOD3Semantics(b, CityModel,bldinf, rel_model, para_path, ID):#, attributes):
    """
    Create LOD3 of the building with an advanced roof shape and semantics (multisurfaces).
    """
    cityObject = etree.SubElement(CityModel, "cityObjectMember")
    bldg = etree.SubElement(cityObject, "{%s}Building" % ns_bldg)
    bldg.attrib['{%s}id' % ns_gml] = ID
    # roofType = etree.SubElement(bldg, "{%s}roofType" % ns_bldg)
    wallface(b, bldg, bldinf, rel_model, para_path)

    # yearOfConstructionXML = etree.SubElement(bldg, "{%s}yearOfConstruction" % ns_bldg)
    # yearOfConstructionXML.text = attributes['yearOfConstruction']
    # functionXML = etree.SubElement(bldg, "{%s}function" % ns_bldg)
    # functionXML.text = attributes['function']
    # storeysAboveGroundXML = etree.SubElement(bldg, "{%s}storeysAboveGround" % ns_bldg)
    # storeysAboveGroundXML.text = attributes['storeysAboveGround']


def transpos(LinearRing):
    listPoints=[]
    lr=LinearRing.split()
    assert(len(lr) % 3 == 0)
    for i in range(0, len(lr), 3):
        listPoints.append((float(lr[i]), float(lr[i+1]), float(lr[i+2])))
    return listPoints

def transcoord(ring,s):
    coordlist=[]
    cl=ring.split()
    sc,sr=s[0:2]
    assert(len(cl) % 2 == 0)
    for i in range(0, len(cl), 2):
        coordlist.append(((float(cl[i]))*sr, (1-float(cl[i+1]))*sc))
    return coordlist



if  __name__ == "__main__":
    # Create citygml document
    import time
    st = time.time()
    CityGMLs = {}
    
    suffix = 'LOD3.36'
    CityGMLs[suffix] = createCityGML(suffix)
    
    
    para_path = r'adjust_para2'
    FULLPATH = "../3910_5821.gml"#DIRECTORY + f
    
    CITYGML = etree.parse(FULLPATH)
    root = CITYGML.getroot()
    cityObjects = []
    buildings = []
    
    listofxmlroofsurfaces = []
    roofsurfacedata = {}
    
    #-- Find all instances of cityObjectMember and put them in a list
    for obj in root.getiterator('{%s}cityObjectMember'% ns_citygml):
        cityObjects.append(obj)
    
    # print (FILENAME)
    print ("\tThere are", len(cityObjects), "cityObject(s) in this CityGML file")
    
    for cityObject in cityObjects:
        for child in cityObject.getchildren():
            if child.tag == '{%s}Building' %ns_bldg:
                buildings.append(child)
    
    #-- Store the buildings as classes
    rel_model = joblib.load(r'img_model.pkl')
    ct = 0
    buildingclasses = []
    for b in buildings:
        id = b.attrib['{%s}id' %ns_gml]
        print (ct)
        bldinf = Building(b, id)
        CityGMLbuildingLOD3Semantics(b, CityGMLs[suffix], bldinf, rel_model, para_path, id)#, attributes)
        ct += 1
        # break
    print ("\tI have read all buildings, now I will search for roofs and estimate their solar irradiation...")
    
    
    storeCityGML(CityGMLs,suffix)
    et = time.time()
    # print ("st:",st,"et:",et,"total:",et-st)
    print ("sss: {:.2f}s".format(et - st))















































